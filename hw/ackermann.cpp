#include <iostream>
#include <vector>
#include <cassert>

#include "ackermann.h"

int main() {
    auto sol = ackermann::solve({1, 1});
    cout << "Result: " << sol[0] << endl;
    cout << "Godel numeration of operations sequence: " << sol[1];

    cout << endl << endl;

    auto sol2 = ackermann2::solve({1, 1});
    cout << "Result: " << sol2[0] << endl;
    cout << "Recursion depth: " << sol2[1];
}

/*
    План:
 1) Демонстрация
 2) Интуитивное не ПРФ. Проблема: почему нельзя вычислить напрямую?
 3) Почему программа1 рекурсивная?
 4) Почему программа2 рекурсивная?

    Конспективно:
 2) Мы не знаем за сколько шагов придем к ответу. Нет примитива, который бы решал эту проблему.
    Конструкция if else в ПРФ работает так: исполним обе ветки, вернем ту у которой нужный бранч.
    Но тут нет примитива, чтобы остановить рекурсию.

 3) Заметим, что структура функции такова,
    что стек вызовов эквивалентен A(s1, A(s2, A(s3, (..., A(s{n-1}, sn)...)))

    На самом деле здесь вектора - гёделева нумерация. Значит у функция фиксированная арность.
    Там где вычислется лист сразу - можно бы было заменить на тупой проход,
    в каждый момент вычисляя один элемент. Примерно как в функции length.

    Используется примитив mu-minimization для поиска нужной последовательности бранчей.
    Для валидации бранча используется примитив рекурсия, т.к. знаем глубину.

 4) Как 3, только считаем все бранчи, но выбираем что нужно.

    Ссылки:
    https://en.wikipedia.org/wiki/Ackermann_function
    https://math.stackexchange.com/questions/1278548/ackermanns-function-is-mu-recursive
 */
